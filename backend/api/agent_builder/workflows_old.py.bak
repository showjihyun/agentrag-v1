"""Agent Builder API endpoints for workflow management."""

import logging
from typing import Optional, Dict, Any

from fastapi import APIRouter, Depends, HTTPException, status, Query, Header
from sqlalchemy.orm import Session

from backend.core.auth_dependencies import get_current_user
from backend.db.database import get_db
from backend.db.models.user import User
from backend.services.agent_builder.workflow_service import WorkflowService
from backend.models.agent_builder import (
    WorkflowCreate,
    WorkflowUpdate,
    WorkflowResponse,
    WorkflowListResponse,
    WorkflowValidationResult,
    WorkflowCompileResult,
    WorkflowValidationResponse,
)

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/api/agent-builder/workflows",
    tags=["agent-builder-workflows"],
)


@router.post(
    "",
    response_model=WorkflowResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new workflow",
    description="Create a new agent workflow with nodes and edges.",
)
async def create_workflow(
    workflow_data: WorkflowCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Create a new workflow.
    
    **Requirements:** 4.1, 4.5
    
    **Request Body:**
    - name: Workflow name (required)
    - description: Workflow description
    - graph_definition: LangGraph workflow definition with nodes and edges
    
    **Returns:**
    - Workflow object with ID and metadata
    
    **Errors:**
    - 400: Invalid request data
    - 401: Unauthorized
    - 500: Internal server error
    """
    try:
        logger.info(f"Creating workflow for user {current_user.id}: {workflow_data.name}")
        
        workflow_service = WorkflowService(db)
        workflow = workflow_service.create_workflow(
            user_id=str(current_user.id),
            workflow_data=workflow_data
        )
        
        logger.info(f"Workflow created successfully: {workflow.id}")
        return workflow
        
    except ValueError as e:
        logger.warning(f"Invalid workflow data: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Failed to create workflow: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create workflow"
        )


@router.get(
    "/{workflow_id}",
    response_model=WorkflowResponse,
    summary="Get workflow by ID",
    description="Retrieve a specific workflow by ID.",
)
async def get_workflow(
    workflow_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Get workflow by ID.
    
    **Requirements:** 4.1
    
    **Path Parameters:**
    - workflow_id: Workflow UUID
    
    **Returns:**
    - Workflow object with full details
    
    **Errors:**
    - 401: Unauthorized
    - 403: Forbidden (no permission to access)
    - 404: Workflow not found
    - 500: Internal server error
    """
    try:
        logger.info(f"Fetching workflow {workflow_id} for user {current_user.id}")
        
        workflow_service = WorkflowService(db)
        workflow = await workflow_service.get_workflow(workflow_id)
        
        if not workflow:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Workflow {workflow_id} not found"
            )
        
        # Check permissions (owner or public)
        if workflow.user_id != str(current_user.id) and not workflow.is_public:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to access this workflow"
            )
        
        return workflow
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get workflow: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve workflow"
        )


@router.put(
    "/{workflow_id}",
    response_model=WorkflowResponse,
    summary="Update workflow",
    description="Update an existing workflow. Requires ownership.",
)
async def update_workflow(
    workflow_id: str,
    workflow_data: WorkflowUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Update workflow.
    
    **Requirements:** 4.1, 4.5
    
    **Path Parameters:**
    - workflow_id: Workflow UUID
    
    **Request Body:**
    - Fields to update (all optional)
    
    **Returns:**
    - Updated workflow object
    
    **Errors:**
    - 400: Invalid request data
    - 401: Unauthorized
    - 403: Forbidden (not owner)
    - 404: Workflow not found
    - 500: Internal server error
    """
    try:
        logger.info(f"Updating workflow {workflow_id} for user {current_user.id}")
        
        workflow_service = WorkflowService(db)
        
        # Check ownership
        existing_workflow = await workflow_service.get_workflow(workflow_id)
        if not existing_workflow:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Workflow {workflow_id} not found"
            )
        
        if existing_workflow.user_id != str(current_user.id):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to update this workflow"
            )
        
        # Update workflow
        updated_workflow = workflow_service.update_workflow(workflow_id, workflow_data)
        
        logger.info(f"Workflow updated successfully: {workflow_id}")
        return updated_workflow
        
    except HTTPException:
        raise
    except ValueError as e:
        logger.warning(f"Invalid workflow data: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Failed to update workflow: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update workflow"
        )


@router.delete(
    "/{workflow_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete workflow",
    description="Delete a workflow. Requires ownership.",
)
async def delete_workflow(
    workflow_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Delete workflow.
    
    **Requirements:** 4.5
    
    **Path Parameters:**
    - workflow_id: Workflow UUID
    
    **Returns:**
    - 204 No Content on success
    
    **Errors:**
    - 401: Unauthorized
    - 403: Forbidden (not owner)
    - 404: Workflow not found
    - 500: Internal server error
    """
    try:
        logger.info(f"Deleting workflow {workflow_id} for user {current_user.id}")
        
        workflow_service = WorkflowService(db)
        
        # Check ownership
        existing_workflow = workflow_service.get_workflow(workflow_id)
        if not existing_workflow:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Workflow {workflow_id} not found"
            )
        
        if existing_workflow.user_id != str(current_user.id):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to delete this workflow"
            )
        
        # Delete workflow
        workflow_service.delete_workflow(workflow_id)
        
        logger.info(f"Workflow deleted successfully: {workflow_id}")
        return None
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to delete workflow: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete workflow"
        )


@router.get(
    "",
    response_model=WorkflowListResponse,
    summary="List workflows",
    description="List workflows with filtering and search.",
)
async def list_workflows(
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(50, ge=1, le=100, description="Maximum number of records to return"),
    search: Optional[str] = Query(None, description="Search in name and description"),
    include_public: bool = Query(True, description="Include public workflows"),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    List workflows with filtering.
    
    **Requirements:** 4.1
    
    **Query Parameters:**
    - skip: Number of records to skip (default: 0)
    - limit: Maximum records to return (default: 50, max: 100)
    - search: Search in name and description
    - include_public: Include public workflows (default: true)
    
    **Returns:**
    - List of workflows with pagination metadata
    
    **Errors:**
    - 401: Unauthorized
    - 500: Internal server error
    """
    try:
        logger.info(f"Listing workflows for user {current_user.id}")
        
        workflow_service = WorkflowService(db)
        
        # Get workflows based on filters
        if include_public:
            # Get user's workflows + public workflows
            workflows = workflow_service.list_workflows(
                user_id=None,  # Get all
                is_public=None,  # Both public and private
                limit=limit,
                offset=skip
            )
            # Filter to show user's own workflows or public ones
            workflows = [w for w in workflows if w.user_id == str(current_user.id) or w.is_public]
        else:
            # Get only user's workflows
            workflows = workflow_service.list_workflows(
                user_id=str(current_user.id),
                is_public=None,
                limit=limit,
                offset=skip
            )
        
        # Apply search filter if provided
        if search:
            search_lower = search.lower()
            workflows = [
                w for w in workflows 
                if search_lower in w.name.lower() or 
                (w.description and search_lower in w.description.lower())
            ]
        
        total = len(workflows)
        
        return WorkflowListResponse(
            workflows=workflows,
            total=total,
            skip=skip,
            limit=limit
        )
        
    except Exception as e:
        logger.error(f"Failed to list workflows: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to list workflows"
        )


@router.post(
    "/{workflow_id}/validate",
    response_model=WorkflowValidationResult,
    summary="Validate workflow",
    description="Validate workflow graph for cycles, disconnected nodes, and invalid state transitions.",
)
async def validate_workflow(
    workflow_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Validate workflow graph.
    
    **Requirements:** 4.5, 13.5
    
    **Path Parameters:**
    - workflow_id: Workflow UUID
    
    **Returns:**
    - Validation result with errors and warnings
    
    **Errors:**
    - 401: Unauthorized
    - 403: Forbidden (no permission to access)
    - 404: Workflow not found
    - 500: Internal server error
    """
    try:
        logger.info(f"Validating workflow {workflow_id}")
        
        workflow_service = WorkflowService(db)
        
        # Check if workflow exists and user has access
        workflow = await workflow_service.get_workflow(workflow_id)
        if not workflow:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Workflow {workflow_id} not found"
            )
        
        # Check permissions (owner or public)
        if workflow.user_id != str(current_user.id) and not workflow.is_public:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to validate this workflow"
            )
        
        # Validate workflow
        validation_result = await workflow_service.validate_workflow(workflow.graph_definition)
        
        logger.info(f"Workflow validated: {workflow_id}, valid={validation_result.is_valid}")
        return validation_result
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to validate workflow: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to validate workflow"
        )


@router.post(
    "/{workflow_id}/compile",
    response_model=WorkflowCompileResult,
    summary="Compile workflow to LangGraph",
    description="Compile workflow definition to LangGraph StateGraph.",
)
async def compile_workflow(
    workflow_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Compile workflow to LangGraph.
    
    **Requirements:** 13.5
    
    **Path Parameters:**
    - workflow_id: Workflow UUID
    
    **Returns:**
    - Compilation result with success status
    
    **Errors:**
    - 400: Invalid workflow definition
    - 401: Unauthorized
    - 403: Forbidden (no permission to access)
    - 404: Workflow not found
    - 500: Internal server error
    """
    try:
        logger.info(f"Compiling workflow {workflow_id}")
        
        workflow_service = WorkflowService(db)
        
        # Check if workflow exists and user has access
        workflow = await workflow_service.get_workflow(workflow_id)
        if not workflow:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Workflow {workflow_id} not found"
            )
        
        # Check permissions (owner or public)
        if workflow.user_id != str(current_user.id) and not workflow.is_public:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to compile this workflow"
            )
        
        # Compile workflow
        compile_result = await workflow_service.compile_workflow(workflow_id)
        
        logger.info(f"Workflow compiled: {workflow_id}, success={compile_result.success}")
        return compile_result
        
    except HTTPException:
        raise
    except ValueError as e:
        logger.warning(f"Invalid workflow definition: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Failed to compile workflow: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to compile workflow"
        )


@router.post(
    "/{workflow_id}/execute",
    summary="Execute workflow",
    description="Execute a workflow with given input data.",
)
async def execute_workflow(
    workflow_id: str,
    input_data: Dict[str, Any],
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Execute workflow with input data.
    
    **Path Parameters:**
    - workflow_id: Workflow UUID
    
    **Request Body:**
    - input: Input data for workflow execution
    
    **Returns:**
    - Execution result with output data
    
    **Errors:**
    - 400: Invalid input data
    - 401: Unauthorized
    - 403: Forbidden
    - 404: Workflow not found
    - 500: Internal server error
    """
    try:
        logger.info(f"Executing workflow {workflow_id} for user {current_user.id}")
        
        workflow_service = WorkflowService(db)
        
        # Check if workflow exists and user has access
        workflow = await workflow_service.get_workflow(workflow_id)
        if not workflow:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Workflow {workflow_id} not found"
            )
        
        # Check permissions
        if workflow.user_id != str(current_user.id) and not workflow.is_public:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to execute this workflow"
            )
        
        # Execute workflow
        result = await workflow_service.execute_workflow(
            workflow_id=workflow_id,
            input_data=input_data,
            user_id=str(current_user.id)
        )
        
        logger.info(f"Workflow executed successfully: {workflow_id}")
        return result
        
    except HTTPException:
        raise
    except ValueError as e:
        logger.warning(f"Invalid input data: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Failed to execute workflow: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to execute workflow"
        )


@router.post(
    "/{workflow_id}/execute-api",
    summary="Execute workflow via API key",
    description="Execute a workflow using API key authentication (no user session required).",
)
async def execute_workflow_api(
    workflow_id: str,
    request_data: Dict[str, Any],
    x_api_key: str = Header(..., description="API key for authentication"),
    db: Session = Depends(get_db),
):
    """
    Execute workflow via API key.
    
    This endpoint allows workflow execution using API key authentication,
    suitable for external integrations and automation.
    
    **Path Parameters:**
    - workflow_id: Workflow UUID
    
    **Headers:**
    - X-API-Key: API key for authentication
    
    **Request Body:**
    - input_data: Input data for workflow execution
    
    **Returns:**
    - Execution result with output data
    
    **Errors:**
    - 400: Invalid request data
    - 401: Invalid API key
    - 404: Workflow not found
    - 429: Rate limit exceeded
    - 500: Internal server error
    """
    from backend.core.triggers.manager import TriggerManager
    from backend.core.triggers.api import APITrigger
    
    try:
        logger.info(f"API execution request for workflow {workflow_id}")
        
        # Get workflow
        workflow_service = WorkflowService(db)
        workflow = await workflow_service.get_workflow(workflow_id)
        
        if not workflow:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Workflow {workflow_id} not found"
            )
        
        # Create API trigger instance
        api_trigger = APITrigger(
            workflow_id=workflow_id,
            config={
                "api_key": x_api_key,  # Will be validated against stored key
                "rate_limit": 100,
                "rate_limit_window": 3600,
            },
            db_session=db
        )
        
        # Validate API key
        # TODO: Load actual API key from database/config
        # For now, we'll use a simple validation
        if not api_trigger.validate_api_key(x_api_key):
            logger.warning(f"Invalid API key for workflow {workflow_id}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid API key"
            )
        
        # Check rate limit
        is_allowed, retry_after = api_trigger.check_rate_limit(x_api_key)
        if not is_allowed:
            logger.warning(f"Rate limit exceeded for workflow {workflow_id}")
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail=f"Rate limit exceeded. Retry after {retry_after} seconds",
                headers={"Retry-After": str(retry_after)}
            )
        
        # Validate request
        is_valid, error_msg = api_trigger.validate_request(request_data)
        if not is_valid:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=error_msg
            )
        
        # Execute workflow
        trigger_manager = TriggerManager(db)
        result = await trigger_manager.execute_trigger(
            workflow_id=workflow_id,
            trigger_type="api",
            trigger_data=request_data.get("input_data", {}),
            user_id=str(workflow.user_id)
        )
        
        # Format response
        formatted_response = api_trigger.format_response(result)
        
        logger.info(f"API workflow executed: {workflow_id}")
        return formatted_response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to execute workflow via API: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to execute workflow"
        )


@router.post(
    "/{workflow_id}/duplicate",
    response_model=WorkflowResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Duplicate workflow",
    description="Create a copy of an existing workflow.",
)
async def duplicate_workflow(
    workflow_id: str,
    name: Optional[str] = None,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Duplicate an existing workflow.
    
    **Path Parameters:**
    - workflow_id: Workflow UUID to duplicate
    
    **Query Parameters:**
    - name: Optional new name for duplicated workflow
    
    **Returns:**
    - New workflow object
    
    **Errors:**
    - 401: Unauthorized
    - 403: Forbidden
    - 404: Workflow not found
    - 500: Internal server error
    """
    try:
        logger.info(f"Duplicating workflow {workflow_id} for user {current_user.id}")
        
        workflow_service = WorkflowService(db)
        
        # Check if workflow exists and user has access
        workflow = await workflow_service.get_workflow(workflow_id)
        if not workflow:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Workflow {workflow_id} not found"
            )
        
        # Check permissions (owner or public)
        if workflow.user_id != str(current_user.id) and not workflow.is_public:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to duplicate this workflow"
            )
        
        # Duplicate workflow
        new_workflow = await workflow_service.duplicate_workflow(
            workflow_id=workflow_id,
            user_id=str(current_user.id),
            new_name=name
        )
        
        logger.info(f"Workflow duplicated successfully: {new_workflow.id}")
        return new_workflow
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to duplicate workflow: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to duplicate workflow"
        )


@router.get(
    "/{workflow_id}/executions",
    summary="Get workflow execution history",
    description="Get execution history for a specific workflow.",
)
async def get_workflow_executions(
    workflow_id: str,
    skip: int = Query(0, ge=0),
    limit: int = Query(20, ge=1, le=100),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Get workflow execution history.
    
    **Path Parameters:**
    - workflow_id: Workflow UUID
    
    **Query Parameters:**
    - skip: Number of records to skip
    - limit: Maximum records to return
    
    **Returns:**
    - List of executions with metadata
    
    **Errors:**
    - 401: Unauthorized
    - 403: Forbidden
    - 404: Workflow not found
    - 500: Internal server error
    """
    try:
        logger.info(f"Fetching executions for workflow {workflow_id}")
        
        workflow_service = WorkflowService(db)
        
        # Check if workflow exists and user has access
        workflow = await workflow_service.get_workflow(workflow_id)
        if not workflow:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Workflow {workflow_id} not found"
            )
        
        # Check permissions
        if workflow.user_id != str(current_user.id) and not workflow.is_public:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to view this workflow's executions"
            )
        
        # Get executions
        executions = await workflow_service.get_workflow_executions(
            workflow_id=workflow_id,
            skip=skip,
            limit=limit
        )
        
        return {
            "executions": executions,
            "total": len(executions),
            "skip": skip,
            "limit": limit
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get workflow executions: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get workflow executions"
        )


@router.post(
    "/{workflow_id}/activate",
    response_model=WorkflowResponse,
    summary="Activate workflow",
    description="Activate a workflow for execution.",
)
async def activate_workflow(
    workflow_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Activate workflow.
    
    **Path Parameters:**
    - workflow_id: Workflow UUID
    
    **Returns:**
    - Updated workflow object
    
    **Errors:**
    - 401: Unauthorized
    - 403: Forbidden
    - 404: Workflow not found
    - 500: Internal server error
    """
    try:
        workflow_service = WorkflowService(db)
        
        # Check ownership
        workflow = await workflow_service.get_workflow(workflow_id)
        if not workflow:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Workflow {workflow_id} not found"
            )
        
        if workflow.user_id != str(current_user.id):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to activate this workflow"
            )
        
        # Activate workflow
        updated_workflow = await workflow_service.update_workflow(
            workflow_id,
            WorkflowUpdate(is_active=True)
        )
        
        logger.info(f"Workflow activated: {workflow_id}")
        return updated_workflow
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to activate workflow: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to activate workflow"
        )


@router.post(
    "/{workflow_id}/deactivate",
    response_model=WorkflowResponse,
    summary="Deactivate workflow",
    description="Deactivate a workflow to prevent execution.",
)
async def deactivate_workflow(
    workflow_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Deactivate workflow.
    
    **Path Parameters:**
    - workflow_id: Workflow UUID
    
    **Returns:**
    - Updated workflow object
    
    **Errors:**
    - 401: Unauthorized
    - 403: Forbidden
    - 404: Workflow not found
    - 500: Internal server error
    """
    try:
        workflow_service = WorkflowService(db)
        
        # Check ownership
        workflow = await workflow_service.get_workflow(workflow_id)
        if not workflow:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Workflow {workflow_id} not found"
            )
        
        if workflow.user_id != str(current_user.id):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to deactivate this workflow"
            )
        
        # Deactivate workflow
        updated_workflow = await workflow_service.update_workflow(
            workflow_id,
            WorkflowUpdate(is_active=False)
        )
        
        logger.info(f"Workflow deactivated: {workflow_id}")
        return updated_workflow
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to deactivate workflow: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to deactivate workflow"
        )


@router.post(
    "/{workflow_id}/validate",
    response_model=WorkflowValidationResponse,
    summary="Validate workflow",
    description="Validate workflow structure and configuration.",
)
async def validate_workflow(
    workflow_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Validate a workflow.
    
    Checks for:
    - Cycles in the workflow graph
    - Disconnected nodes
    - Missing required inputs
    - Invalid block configurations
    
    Returns validation errors and warnings.
    """
    try:
        from backend.services.agent_builder.workflow_validator import WorkflowValidator
        from uuid import UUID
        
        validator = WorkflowValidator(db)
        is_valid, errors, warnings = validator.validate_workflow(UUID(workflow_id))
        
        logger.info(f"Workflow {workflow_id} validation: {len(errors)} errors, {len(warnings)} warnings")
        
        return WorkflowValidationResponse(
            is_valid=is_valid,
            errors=errors,
            warnings=warnings
        )
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Error validating workflow: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to validate workflow"
        )
